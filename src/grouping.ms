.bp
.NH
.XN Grouping
.LP
Grouping is a feature of the FBDL used to inform a compiler that particular functionalities might be accessed together and theirs register location must meet additional constraints.
This is achieved using the \f[C]groups\fR property.
The following functionalities can be grouped: \fCconfig\fR,  \fCmask\fR,  \fCstatic\fR,  \fCstatus\fR.
A functionality may belong to multiple groups and groups must be registerified in the order they appear.
The following snippet presents three grouped configs.
.QP
\fCMain \f[CB]bus\fC
.br
	\f[CB]type\fC cfg_t; \f[CB]width\fC = 8; \f[CB]groups\fC = [\f[CI]"group"\fC]
.br
	A cfg_t
.br
	B cfg_t
.br
	C cfg_t
.LP
Any FBDL compliant compiler must place all three configs (\fCA\fR, \fCB\fR, \fCC\fR) in the same register.
.
.NH 2
.XN "Single register groups"
.LP
The single register groups are groups of elements that fit single register.
The overall width of all functionalities is not greater than the single register width.
In such case all functionalities must be placed in the same register.
The specification does not impose any specific order of the functionalities within the register, and it is left to the compiler implementation.
The following listing presents an example bus description with three single register groups.
.QP
\fCMain \f[CB]bus\fC
.br
	C0 \f[CB]config\fC; \f[CB]width\fC = 16; \f[CB]groups\fC = ["\f[CI]read_write_group\fC"]
.br
	M0 \f[CB]mask\fC;   \f[CB]width\fC = 15; \f[CB]groups\fC = ["\f[CI]read_write_group\fC"]
.br

	C1  \f[CB]config\fC; \f[CB]width\fC = 16; \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br
	S11 \f[CB]static\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br
	S12 \f[CB]status\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br

	S21 \f[CB]status\fC; \f[CB]width\fC = 4; \f[CB]groups\fC = ["\f[CI]read_only_group\fC"]
.br
	S22 \f[CB]status\fC; \f[CB]width\fC = 7; \f[CB]groups\fC = ["\f[CI]read_only_group\fC"]
.br
.LP
All functionalities of the \fCread_write_group\fR can be both read and written.
The code generated by a compiler for the requester must provide methods for reading/writing the whole group as well as for read/writing particular functionalities of the group.
.LP
The \fCmixed_group\fR contains functionality that can be read and written (\fCC1\fR), as well as functionalities that can be only read (\fCS11\fR, \fCS12\fR).
The code generated by a compiler for the requester must provide method for reading all readable functionalities and method for writing all writable functionalities.
It is valid even if the group has single readable or single writable functionality.
The compiler must also generate methods for reading/writing particular functionalities of the group.
In case of \fCmixed_group\fR this will results with two methods doing exactly the same (writing the \fCC1\fR config).
However, it is up to the user to decide which of the methods should be used.
If it makes sense, it is perfectly valid to use both of them in different contexts.
.LP
All functionalities of the \fCread_only_group\fR are read only.
In this case the compiler must generate method only for reading the group.
It must also generate methods for reading particular functionalities.
.
.NH 2
.XN "Multi register groups"
.LP
The multi register groups are groups with functionalities that overall width is greater than the width of a single register.
The specification does not impose any order of functionalities or registers in such case, and it is left to the compiler implementation.
However, the compiler must not split functionalities narrower or equal to the register width into multiple registers.
This implies that any functionality with width not greater than the register width is always read or written using single read or write access.
The following snippet presents bus description with one multi register group.
.QP
\fCMain \f[CB]bus\fC
.br
	C  \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	M  \f[CB]mask\fC;   \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	SC \f[CB]static\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	SS \f[CB]status\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.LP
The compiler must generate code for the requester allowing to write all writable functionalities of the group as well as the code allowing reading all readable functionalities of the groups.
It must also generate methods for reading or writing particular functionalities.
.LP
There are multiple ways to place functionalities from the above example into registers.
The following snippet presents one possible way.
.QP
\fC        Nth register              Nth + 1 register
.br
-----------------------------  ----------------------
.br
|| C | M | SC | 2 bits gap ||  || SS | 22 bits gap ||
.br
-----------------------------  ----------------------
\fR
.LP
However, the above arrangement might not be optimal if there is a need to read both \fCSC\fR and \fCSS\fR at the same time as it would require reading two registers not a single one.
Below listing presents how to group elements within the group using subgroups.
.QP
\fCMain \f[CB]bus\fC
.br
	C  \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]csubgroup\fC", "\f[CI]group"\fC]
.br
	M  \f[CB]mask\fC;   \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]csubgroup\fC", "\f[CI]group"\fC]
.br
	SC \f[CB]static\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]ssubgroup\fC", "\f[CI]group"\fC]
.br
	SS \f[CB]status\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]ssubgroup\fC", "\f[CI]group"\fC]
.LP
The set of possible functionalities placements within the registers is now limited as the groups are registerified in the order they appear.
Below snippet shows possible arrangement.
.QP
\fC       Nth register              Nth + 1 register
.br
-------------------------  ---------------------------
.br
|| C | M | 12 bits gap ||  || SC | SS | 12 bits gap ||
.br
-------------------------  ---------------------------
\fR
.LP
This time reading both \fCSC\fR and \fCSS\fR requires reading only one register, while reading the whole \fCgroup\fR still requires reading two registers.
.
.NH 2
.XN "Array groups"
.LP
.NH 2
.XN "Mixed groups"
.LP
.NH 2
.XN "Virtual groups"
.LP
Virtual groups are groups that name starts with the underscore ('_'), for example "\f[CI]_group\fR".
Virtual groups are used to group functionalities without generating the group interface for the requester code.
.NH 2
.XN "Registerification order"
.LP
Groups must be registerified in the order they appear in the groups lists.
If the order is not unequivocal, then the compiler is free to choose the order.
The order of groups might be used to prioritize the groups, so that an access to some groups is more efficient than to the other groups.
Below listing serves as an example.
.QP
\fCMain \f[CB]bus\fC
.br
	C1 \f[CB]config\fC; \f[CB]width\fC = 20; \f[CB]groups\fC = ["\f[CI]a\fC"]
.br
	C2 \f[CB]config\fC; \f[CB]width\fC = 12; \f[CB]groups\fC = ["\f[CI]a\fC", "\f[CI]b\fC"]
.br
	C3 \f[CB]config\fC; \f[CB]width\fC = 20; \f[CB]groups\fC = ["\f[CI]b\fC"]
.LP
As group \fCa\fR has higher priority than group \fCb\fR (its index is lower in the groups list for functionality \fCC2\fR), access to the group \fCa\fR will be more efficient, as functionalities \fCC1\fR and \fCC2\fR will be placed in the same register.
Possible arrangement is presented in the below snippet.
.QP
\fCNth register     Nth + 1 register
.br
-------------  ----------------------
.br
|| C1 | C2 ||  || C3 | 12 bits gap ||
.br
-------------  ----------------------
\fR
.LP
If the order of the groups in the groups list for functionality \fCC2\fR was reverse, then the access to the group \fCb\fR would be more efficient.
Possible arrangement of functionalities in such case could look as follows.
.QP
\fCNth register     Nth + 1 register
.br
-------------  ----------------------
.br
|| C2 | C3 ||  || C1 | 12 bits gap ||
.br
-------------  ----------------------
\fR
.LP
\fBTODO: Add example with unequivocal group order.\fR

.bp
.NH
.XN Grouping
.LP
Grouping is a feature of the FBDL used to inform a compiler that particular functionalities might be accessed together, and their register location must meet additional constraints.
This is achieved using the \f[C]groups\fR property.
The following functionalities can be grouped: \fCconfig\fR,  \fCirq\fR,  \fCmask\fR,  \fCstatic\fR,  \fCstatus\fR.
A functionality may belong to multiple groups (except \fCirq\fR), and groups must be registerified in the order they appear in the group lists.
The following snippet presents three grouped configs.
.QP
\fCMain \f[CB]bus\fC
.br
	\f[CB]type\fC cfg_t; \f[CB]width\fC = 8; \f[CB]groups\fC = [\f[CI]"group"\fC]
.br
	A cfg_t
.br
	B cfg_t
.br
	C cfg_t
.LP
Any FBDL compliant compiler must place all three configs (\fCA\fR, \fCB\fR, \fCC\fR) in the same register.
.
.
.NH 2
.XN Single register groups
.LP
The single register groups are groups of elements that fit a single register.
The overall width of all functionalities is not greater than the single register width.
In such a case, all functionalities must be placed in the same register.
The specification does not impose any specific order of the functionalities within the register, and it is left to the compiler implementation.
The following listing presents an example bus description with three single register groups.
.QP
\fCMain \f[CB]bus\fC
.br
	C0 \f[CB]config\fC; \f[CB]width\fC = 16; \f[CB]groups\fC = ["\f[CI]read_write_group\fC"]
.br
	M0 \f[CB]mask\fC;   \f[CB]width\fC = 15; \f[CB]groups\fC = ["\f[CI]read_write_group\fC"]
.br

	C1  \f[CB]config\fC; \f[CB]width\fC = 16; \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br
	S11 \f[CB]static\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br
	S12 \f[CB]status\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br

	S21 \f[CB]status\fC; \f[CB]width\fC = 4; \f[CB]groups\fC = ["\f[CI]read_only_group\fC"]
.br
	S22 \f[CB]status\fC; \f[CB]width\fC = 7; \f[CB]groups\fC = ["\f[CI]read_only_group\fC"]
.br
.LP
All functionalities of the \f[CI]"read_write_group"\fR can be both read and written.
The code generated by a compiler for the requester must provide means for reading/writing the whole group as well as for reading/writing particular functionalities of the group.
.LP
The \f[CI]"mixed_group"\fR contains functionality that can be read and written (\fCC1\fR), as well as functionalities that can only be read (\fCS11\fR, \fCS12\fR).
The code generated by a compiler for the requester must provide a means for reading all readable functionalities and writing all writable functionalities.
It is valid even if the group has single readable or single writable functionality.
The compiler must also generate means for reading/writing particular functionalities of the group.
In the case of \f[CI]"mixed_group"\fR this will result in two means doing exactly the same (writing the \fCC1\fR config).
However, it is up to the user to decide which of the means should be used.
If it makes sense, it is perfectly valid to use both of them in different contexts.
.LP
All functionalities of the \f[CI]"read_only_group"\fR are read-only.
In this case, the compiler must generate a mean only for reading the group.
It must also generate means for reading particular functionalities.
.
.
.NH 2
.XN Multi register groups
.LP
The multi register groups are groups with functionalities that overall width is greater than the width of a single register.
The specification does not impose any order of functionalities or registers in such cases, and it is left to the compiler implementation.
However, the compiler must not split functionalities narrower or equal to the register width into multiple registers.
This implies that any functionality with a width not greater than the register width is always read or written using single read or write access.
The following snippet presents a bus description with one multi register group.
.QP
\fCMain \f[CB]bus\fC
.br
	C  \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	M  \f[CB]mask\fC;   \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	SC \f[CB]static\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	SS \f[CB]status\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.LP
The compiler must generate code for the requester allowing to write all writable functionalities of the group as well as the code allowing reading all readable functionalities of the groups.
It must also generate means for reading or writing particular functionalities.
.LP
There are multiple ways to place functionalities from the above example into registers.
The following snippet presents one possible way.
.QP
\fC        Nth register              Nth + 1 register
.br
-----------------------------  ----------------------
.br
|| C | M | SC | 2 bits gap ||  || SS | 22 bits gap ||
.br
-----------------------------  ----------------------
\fR
.LP
However, the above arrangement might not be optimal if there is a need to read both \fCSC\fR and \fCSS\fR at the same time as it would require reading two registers not a single one.
The below listing presents how to group elements within the group using subgroups.
.QP
\fCMain \f[CB]bus\fC
.br
	C  \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]csubgroup\fC", "\f[CI]group"\fC]
.br
	M  \f[CB]mask\fC;   \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]csubgroup\fC", "\f[CI]group"\fC]
.br
	SC \f[CB]static\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]ssubgroup\fC", "\f[CI]group"\fC]
.br
	SS \f[CB]status\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]ssubgroup\fC", "\f[CI]group"\fC]
.LP
The set of possible functionalities placements within the registers is now limited as the groups are registerified in the order they appear.
The below snippet shows a possible arrangement.
.QP
\fC       Nth register              Nth + 1 register
.br
-------------------------  ---------------------------
.br
|| C | M | 12 bits gap ||  || SC | SS | 12 bits gap ||
.br
-------------------------  ---------------------------
\fR
.LP
This time reading both \fCSC\fR and \fCSS\fR requires reading only one register, while reading the whole \f[CI]"group"\fR still requires reading two registers.
.
.
.NH 2
.XN Array groups
.LP
The array groups are groups with all functionalities being arrays.
The groups do not necessarily have the same number of elements.
.LP
The code generated by a compiler, for an array group, for the requester must provide a means for writing an arbitrary number of elements for all writable functionalities starting from an arbitrary index.
It must also provide a mean for reading an arbitrary number of elements for all readable functionalities starting from an arbitrary index.
.LP
The specification does not define what happens on access to the elements with an index greater than the length of some arrays.
This is because some of the target languages support special data types indicating that the value is absent (for example, \fCNone\fR - Python, \fCOption\fR - Rust), while others use for this purpose completely valid values (\fC0\fR - C, Go).
.
.
.NH 3
.XN Single register array groups
.LP
The single register array groups are array groups with overall single elements width not greater than the width of a single register.
The below listing presents an example bus description with a single register array group.
.QP
\fCMain \f[CB]bus\fC
.br
	\f[CB]type\fC cfg_t \f[CB]config\fC; \f[CB]width\fC = 8; \f[CB]groups\fC = \f[CI]"group"\fC
.br
	A [1]cfg_t
.br
	B [2]cfg_t
.br
	C [3]cfg_t
.br
	D [3]status; \f[CB]width\fC = 8; \f[CB]groups\fC = "\f[CI]group\fC"
.LP
In the case of a single register array group all elements with corresponding indices must be placed in the same register.
Elements with consecutive indexes must be placed in consecutive registers.
The below snippet presents a possible arrangement of elements for the example bus.
.QP
\fC         Nth register
.br
-------------------------------
.br
|| D[0] | C[0] | B[0] | A[0] ||
.br
-------------------------------
.br
         Nth + 1 register
.br
-------------------------------------
.br
|| D[1] | C[1] | B[1] | 8 bits gap ||
.br
-------------------------------------
.br
         Nth + 2 register
.br
-------------------------------
.br
|| D[2] | C[2] | 16 bits gap ||
.br
-------------------------------
.
.
.NH 3
.XN Multi register array groups
.LP
The single register array groups are array groups with overall single elements width greater than the width of a single register.
The below listing presents an example bus description with a multi register array group.
.QP
\fCMain \f[CB]bus\fC
.br
\f[CB]type\fC cfg_t \f[CB]config\fC; \f[CB]groups\fC = \f[CI]"group"\fC
.br
	A [1]cfg_t; \f[CB]width\fC = 16
.br
	B [2]cfg_t; \f[CB]width\fC = 12
.br
	C [2]cfg_t; \f[CB]width\fC = 12
\fR
.LP
In the case of multi register array group all elements with corresponding indices must be placed in consecutive registers.
Also all elements with consecutive indexes must be placed in consecutive registers.
Such a requirement guarantees that block access can always be used.
The below snippet presents possible arrangement of elements for the example bus.
.QP
\fC         Nth register                Nth + 1 register
.br
------------------------------   ------------------------
.br
|| C[0] | B[0] | 8 bits gap ||   || A[0] | 16 bits gap ||
.br
------------------------------   ------------------------
.br
       Nth + 2 register                 Nth + 3 register
.br
------------------------------   ------------------------------
.br
|| C[1] | B[1] | 8 bits gap ||   || C[2] | B[2] | 8 bits gap ||
.br
------------------------------   ------------------------------
.
.
.NH 2
.XN Mixed groups
.LP
The mixed groups are groups with both single functionalities and array functionalities.
The below listing presents an example bus description with a mixed group.
.QP
\fCMain \f[CB]bus\fC
.br
	C \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\fC = \f[CI]"group"\fC
.br
	M \f[CB]mask\fC;   \f[CB]width\fC = 7;  \f[CB]groups\fC = \f[CI]"group"\fC
.br
	S \f[CB]status\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = \f[CI]"group"\fC
.br

.br
	CA [3]\f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\fC = \f[CI]"group"\fC
.br
	SA [3]\f[CB]config\fC; \f[CB]width\fC = 12; \f[CB]groups\fC = \f[CI]"group"\fC
.LP
In case of mixed groups array functionalities shall be registerified as the first ones assuming a pure array group.
Single functionalities shall be later placed in the gaps created during array registerification.
If there are no gaps, or gaps are not wide enough, then all reamining single functionalities shall be registerified as single register group or multi register group.
If the gaps are wide enough to place single functionalities there, but for some reason it is not desired, then subgroup can be defined to group single functionalities of the mixed group as the first ones.
The below snippet presents a possible arrangement of elements for the example bus.
.QP
\fC      Nth register                  Nth + 1 register
.br
-----------------------   ------------------------------------
.br
|| CA[0] | SA[0] | C ||   || CA[1] | SA[1] | M | 3 bits gap ||
.br
-----------------------   ------------------------------------
          Nth + 2 register
.br
------------------------------------
.br
|| CA[2] | SA[2] | S | 2 bits gap ||
.br
------------------------------------
\fR
.
.
.NH 2
.XN Virtual groups
.LP
Virtual groups are groups that name starts with the underscore ('_'), for example "\f[CI]_group\fR".
Virtual groups are used to group functionalities without generating the group interface for the requester code.

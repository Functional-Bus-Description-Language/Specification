.bp
.NH
.XN Grouping
.LP
Grouping is a feature of the FBDL used to inform a compiler that particular functionalities might be accessed together and theirs register location must meet additional constraints.
This is achieved using the \f[C]groups\fR property.
The following functionalities can be grouped: \fCconfig\fR,  \fCmask\fR,  \fCstatic\fR,  \fCstatus\fR.
A functionality may belong to multiple groups and groups must be registerified in the order they appear.
The following snippet presents three grouped configs.
.QP
\fCMain \f[CB]bus\fC
.br
	\f[CB]type\fC cfg_t; \f[CB]width\fC = 8; \f[CB]groups\fC = [\f[CI]"group"\fC]
.br
	A cfg_t
.br
	B cfg_t
.br
	C cfg_t
.LP
Any FBDL compliant compiler must place all three configs (\fCA\fR, \fCB\fR, \fCC\fR) in the same register.
.
.NH 2
.XN "Single register groups"
.LP
The single register groups are groups of elements that fit single register.
The overall width of all functionalities is not greater than the single register width.
In such case all functionalities must be placed in the same register.
The specification does not impose any specific order of the functionalities within the register, and it is left to the compiler implementation.
The following listing presents an example bus description with three single register groups.
.QP
\fCMain \f[CB]bus\fC
.br
	C0 \f[CB]config\fC; \f[CB]width\fC = 16; \f[CB]groups\fC = ["\f[CI]read_write_group\fC"]
.br
	M0 \f[CB]mask\fC;   \f[CB]width\fC = 15; \f[CB]groups\fC = ["\f[CI]read_write_group\fC"]
.br

	C1  \f[CB]config\fC; \f[CB]width\fC = 16; \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br
	S11 \f[CB]static\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br
	S12 \f[CB]status\fC; \f[CB]width\fC = 8;  \f[CB]groups\fC = ["\f[CI]mixed_group\fC"]
.br

	S21 \f[CB]status\fC; \f[CB]width\fC = 4; \f[CB]groups\fC = ["\f[CI]read_only_group\fC"]
.br
	S22 \f[CB]status\fC; \f[CB]width\fC = 7; \f[CB]groups\fC = ["\f[CI]read_only_group\fC"]
.br
.LP
All functionalities of the \fCread_write_group\fR can be both read and written.
The code generated by a compiler for the requester must provide methods for reading/writing the whole group as well as for read/writing particular functionalities of the group.
.LP
The \fCmixed_group\fR contains functionality that can be read and written (\fCC1\fR), as well as functionalities that can be only read (\fCS11\fR, \fCS12\fR).
The code generated by a compiler for the requester must provide method for reading all readable functionalities and method for writing all writable functionalities.
It is valid even if the group has single readable or single writable functionality.
The compiler must also generate methods for reading/writing particular functionalities of the group.
In case of \fCmixed_group\fR this will results with two methods doing exactly the same (writing the \fCC1\fR config).
However, it is up to the user to decide which of the methods should be used.
If it makes sense, it is perfectly valid to use both of them in different contexts.
.LP
All functionalities of the \fCread_only_group\fR are read only.
In this case the compiler must generate method only for reading the group.
It must also generate methods for reading particular functionalities.
.
.NH 2
.XN "Multi register groups"
.LP
The multi register groups are groups with functionalities that overall width is greater than the width of a single register.
The specification does not impose any order of functionalities or registers in such case, and it is left to the compiler implementation.
However, the compiler must not split functionalities narrower or equal to the register width into multiple registers.
This implies that any functionality with width not greater than the register width is always read or written using single read or write access.
The following snippet presents bus description with one multi register group.
.QP
\fCMain \f[CB]bus\fC
.br
	C  \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	M  \f[CB]mask\fC;   \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	SC \f[CB]static\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.br
	SS \f[CB]status\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]group"\fC]
.LP
The compiler must generate code for the requester allowing to write all writable functionalities of the group as well as the code allowing reading all readable functionalities of the groups.
It must also generate methods for reading or writing particular functionalities.
.LP
There are multiple ways to place functionalities from the above example into registers.
The following snippet presents one possible way.
.QP
\fC        Nth register              Nth + 1 register
.br
-----------------------------  ----------------------
.br
|| C | M | SC | 2 bits gap ||  || SS | 22 bits gap ||
.br
-----------------------------  ----------------------
\fR
.LP
However, the above arrangement might not be optimal if there is a need to read both \fCSC\fR and \fCSS\fR at the same time as it would require reading two registers not a single one.
Below listing presents how to group elements within the group using subgroups.
.QP
\fCMain \f[CB]bus\fC
.br
	C  \f[CB]config\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]csubgroup\fC", "\f[CI]group"\fC]
.br
	M  \f[CB]mask\fC;   \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]csubgroup\fC", "\f[CI]group"\fC]
.br
	SC \f[CB]static\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]ssubgroup\fC", "\f[CI]group"\fC]
.br
	SS \f[CB]status\fC; \f[CB]width\fC = 10; \f[CB]groups\f[C] = ["\f[CI]ssubgroup\fC", "\f[CI]group"\fC]
.LP
The set of possible functionalities placements within the registers is now limited as the groups are registerified in the order they appear.
Below snippet shows possible arrangement.
.QP
\fC       Nth register              Nth + 1 register
.br
-------------------------  ---------------------------
.br
|| C | M | 12 bits gap ||  || SC | SS | 12 bits gap ||
.br
-------------------------  ---------------------------
\fR
.LP
This time reading both \fCSC\fR and \fCSS\fR requires reading only one register, while reading the whole \fCgroup\fR still requires reading two registers.
.
.NH 2
.XN "Array groups"
.LP
The array groups are groups with all functionalities being arrays.
The groups do not necessarily have the same number of elements.
.LP
The code generated by a compiler, for an array group, for the requester must provide a method for writing arbitrary number of elements for all writable functionalities starting from an arbitrary index.
It must also provide a method for reading arbitrary number of elements for all readable functionalities starting from an arbitrary index.
.LP
The specification does not define what happens on access to the elements with index greater than the length of some arrays.
This is because some of the target languages support special data types indicating that the value is absent (for example \fCNone\fR - Python, \fCOption\fR - Rust), while others use for this purpose completely valid values (\fC0\fR - C, Go).
.NH 3
.XN "Single register array groups"
.LP
The single register array groups are array groups with overall single elements width not greater than the width of a single register.
Below listing presents an example bus description with a single register array group.
.QP
\fCMain \f[CB]bus\fC
.br
	\f[CB]type\fC cfg_t; \f[CB]width\fC = 8; \f[CB]groups\fC = [\f[CI]"group"\fC]
.br
	A [1]cfg_t
.br
	B [2]cfg_t
.br
	C [3]cfg_t
.br
	D [3]status; \f[CB]width\fC = 8; \f[CB]groups\fC = ["\f[CI]group\fC"]
.LP
In case of single register array group all elements with corresponding indices must be placed in the same register.
Below snippet presents possible arrangement of elements for the example bus.
.QP
\fC         Nth register
.br
-------------------------------
.br
|| D[0] | C[0] | B[0] | A[0] ||
.br
-------------------------------
.br
         Nth + 1 register
.br
-------------------------------------
.br
|| D[1] | C[1] | B[1] | 8 bits gap ||
.br
-------------------------------------
.br
         Nth + 2 register
.br
-------------------------------
.br
|| D[2] | C[2] | 16 bits gap ||
.br
-------------------------------
.NH 2
.XN "Mixed groups"
.LP
The mixed groups are groups with both single functionalities and array functionalities.
The below listing presents an example bus description with a mixed group.
.NH 2
.XN "Virtual groups"
.LP
Virtual groups are groups that name starts with the underscore ('_'), for example "\f[CI]_group\fR".
Virtual groups are used to group functionalities without generating the group interface for the requester code.
